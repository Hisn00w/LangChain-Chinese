# 多智能体

多智能体系统协调专门的组件来处理复杂的工作流程。然而，并非每个复杂任务都需要这种方法——具有正确（有时是动态）工具和提示的单个智能体通常可以实现类似的结果。

## 为什么要用多智能体？

当开发者说他们需要"多智能体"时，他们通常是在寻找以下一项或多项功能：

* **上下文管理**：提供专门知识而不会压垮模型的上下文窗口。如果上下文是无限的且延迟为零，您可以将所有知识倒入单个提示——但由于事实并非如此，您需要模式来选择性地显示相关信息。
* **分布式开发**：允许不同团队独立开发和维护能力，将它们组合成具有清晰边界的大型系统。
* **并行化**：为子任务生成专门的工作者并并发执行以获得更快的结果。

当单个智能体有太多[工具](/oss/python/langchain/tools)并对使用哪些工具做出错误决策时，当任务需要具有广泛上下文（长提示和特定领域工具）的专门知识时，或者当您需要强制执行顺序约束以仅在满足某些条件后解锁功能时，多智能体模式特别有价值。

<Tip>
  多智能体设计的核心是[上下文工程](/oss/python/langchain/context-engineering)——决定每个智能体看到什么信息。您的系统质量取决于确保每个智能体都能访问其任务所需的正确数据。
</Tip>

## 模式

以下是构建多智能体系统的主要模式，每种模式适用于不同的用例：

| 模式 | 工作方式 |
| ---- | -------- |
| [**子智能体**](/oss/python/langchain/multi-agent/subagents) | 主智能体将子智能体协调为工具。所有路由都通过主智能体，主智能体决定何时以及如何调用每个子智能体。 |
| [**交接**](/oss/python/langchain/multi-agent/handoffs) | 行为根据状态动态变化。工具调用更新触发路由或配置更改的状态变量，切换智能体或调整当前智能体的工具和提示。 |
| [**技能**](/oss/python/langchain/multi-agent/skills) | 按需加载专门的提示和知识。单个智能体保持控制，同时根据需要从技能加载上下文。 |
| [**路由器**](/oss/python/langchain/multi-agent/router) | 路由步骤对输入进行分类并将其定向到一个或多个专门智能体。结果被合成为组合响应。 |
| [**自定义工作流**](/oss/python/langchain/multi-agent/custom-workflow) | 使用 [LangGraph](/oss/python/langgraph/overview) 构建自定义执行流，混合确定性逻辑和智能体行为。将其他模式作为节点嵌入您的工作流中。 |

### 选择模式

使用此表将您的需求与正确的模式匹配：

| 模式 | 分布式开发 | 并行化 | 多跳 | 直接用户交互 |
| ---- | :-------: | :---: | :--: | :---------: |
| **子智能体** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐ |
| **交接** | — | — | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **技能** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **路由器** | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | — | ⭐⭐⭐ |

* **分布式开发**：不同团队可以独立维护组件吗？
* **并行化**：多个智能体可以并发执行吗？
* **多跳**：该模式支持按顺序调用多个子智能体吗？
* **直接用户交互**：子智能体可以直接与用户对话吗？

<Tip>
  您可以混合模式！例如，**子智能体**架构可以调用调用自定义工作流或路由器智能体的工具。子智能体甚至可以使用**技能**模式按需加载上下文！可能性是无穷无尽的！
</Tip>

### 视觉概览

**子智能体：**

主智能体将子智能体协调为工具。所有路由都通过主智能体。

[图片：子智能体模式 - 主智能体将子智能体协调为工具]

**交接：**

智能体通过工具调用相互控制转移。每个智能体可以转移给其他智能体或直接响应用户。

[图片：交接模式 - 智能体通过工具调用转移控制]

**技能：**

单个智能体按需加载专门的提示和知识，同时保持控制。

[图片：技能模式 - 单个智能体按需加载专门上下文]

**路由器：**

路由步骤对输入进行分类并将其定向到专门智能体。结果被合成。

[图片：路由器模式 - 路由步骤将输入分类到专门智能体]

## 性能比较

不同的模式具有不同的性能特征。了解这些权衡有助于您为延迟和成本需求选择正确的模式。

**关键指标：**

* **模型调用**：LLM 调用次数。更多调用 = 更高的延迟（特别是如果是顺序的）和更高的每次请求 API 成本。
* **处理的令牌数**：所有调用中的总[上下文窗口](/oss/python/langchain/context-engineering)使用。更多令牌 = 更高的处理成本和潜在的上下文限制。

### 单次请求

> **用户：**"买咖啡"

专门的咖啡智能体/技能可以调用 `buy_coffee` 工具。

| 模式 | 模型调用 | 最佳适用 |
| ---- | :-----: | :-----: |
| **子智能体** | 4 | |
| **交接** | 3 | ✅ |
| **技能** | 3 | ✅ |
| **路由器** | 3 | ✅ |

**子智能体：**

4 次模型调用：

[图片：子智能体单次请求：4次模型调用]

**交接：**

3 次模型调用：

[图片：交接单次请求：3次模型调用]

**技能：**

3 次模型调用：

[图片：技能单次请求：3次模型调用]

**路由器：**

3 次模型调用：

[图片：路由器单次请求：3次模型调用]

**关键洞察：** 交接、技能和路由器对于单个任务最有效（各3次调用）。子智能体增加了一次额外调用，因为结果通过主智能体流回——这个开销提供了集中控制。

### 重复请求

> **第1轮：**"买咖啡"
> **第2轮：**"再买一次咖啡"

用户在同一个对话中重复相同的请求。

| 模式 | 第2轮调用 | 总计（两轮） | 最佳适用 |
| ---- | :------: | :---------: | :-----: |
| **子智能体** | 4 | 8 | |
| **交接** | 2 | 5 | ✅ |
| **技能** | 2 | 5 | ✅ |
| **路由器** | 3 | 6 | |

**子智能体：**

再次4次调用 → 总计8次

* 子智能体**按设计是无状态的**——每次调用遵循相同的流程
* 主智能体维护对话上下文，但子智能体每次都重新开始
* 这提供了强大的上下文隔离但重复了完整流程

**交接：**

2次调用 → 总计5次

* 咖啡智能体从第1轮开始**仍然处于活动状态**（状态持久化）
* 无需交接——智能体直接调用 `buy_coffee` 工具（第1次调用）
* 智能体响应用户（第2次调用）
* **通过跳过交接节省1次调用**

**技能：**

2次调用 → 总计5次

* 技能上下文**已加载**在对话历史中
* 无需重新加载——智能体直接调用 `buy_coffee` 工具（第1次调用）
* 智能体响应用户（第2次调用）
* **通过重用加载的技能节省1次调用**

**路由器：**

再次3次调用 → 总计6次

* 路由器是**无状态的**——每个请求需要 LLM 路由调用
* 第2轮：路由器 LLM 调用 (1) → 牛奶智能体调用 buy_coffee (2) → 牛奶智能体响应 (3)
* 可以通过在有状态智能体中封装为工具来优化

**关键洞察：** 有状态模式（交接、技能）在重复请求上节省40-50%的调用。子智能体保持每请求一致的成本——这种无状态设计提供了强大的上下文隔离，但代价是重复的模型调用。

### 多领域

> **用户：**"比较用于 Web 开发的 Python、JavaScript 和 Rust"

每个语言智能体/技能包含约2000个令牌的文档。所有模式都可以进行并行工具调用。

| 模式 | 模型调用 | 总令牌数 | 最佳适用 |
| ---- | :-----: | :-----: | :-----: |
| **子智能体** | 5 | ~9K | ✅ |
| **交接** | 7+ | ~14K+ | |
| **技能** | 3 | ~15K | |
| **路由器** | 5 | ~9K | ✅ |

**子智能体：**

5次调用，~9K令牌

[图片：子智能体多领域：5次调用并行执行]

每个子智能体在**隔离状态**下工作，只与其相关上下文一起。总计：**9K令牌**。

**交接：**

7+次调用，~14K+令牌

[图片：交接多领域：7+次顺序调用]

交接**顺序执行**——无法并行研究所有三种语言。不断增长的对话历史增加了开销。总计：**~14K+令牌**。

**技能：**

3次调用，~15K令牌

[图片：技能多领域：3次调用累积上下文]

加载后，**每次后续调用处理所有6K令牌的技能文档**。子智能体由于上下文隔离总体处理67%更少的令牌。总计：**15K令牌**。

**路由器：**

5次调用，~9K令牌

[图片：路由器多领域：5次调用并行执行]

路由器使用**LLM进行路由**，然后并行调用智能体。类似于子智能体但带有显式路由步骤。总计：**9K令牌**。

**关键洞察：** 对于多领域任务，具有并行执行（子智能体、路由器）的模式最有效。技能的调用次数更少，但由于上下文累积导致令牌使用量高。交接在这里效率低下——它必须顺序执行，不能利用并行工具调用同时咨询多个领域。

### 总结

以下是模式在所有三种场景中的比较：

| 模式 | 单次请求 | 重复请求 | 多领域 |
| ---- | :-----: | :-----: | :----: |
| **子智能体** | 4次调用 | 8次调用 (4+4) | 5次调用，9K令牌 |
| **交接** | 3次调用 | 5次调用 (3+2) | 7+次调用，14K+令牌 |
| **技能** | 3次调用 | 5次调用 (3+2) | 3次调用，15K令牌 |
| **路由器** | 3次调用 | 6次调用 (3+3) | 5次调用，9K令牌 |

**选择模式：**

| 优化目标 | 子智能体 | 交接 | 技能 | 路由器 |
| ------- | :-----: | :--: | :--: | :---: |
| 单次请求 | | ✅ | ✅ | ✅ |
| 重复请求 | | ✅ | ✅ | |
| 并行执行 | ✅ | | | ✅ |
| 大上下文领域 | ✅ | | | ✅ |
| 简单、专注的任务 | | | ✅ | |

